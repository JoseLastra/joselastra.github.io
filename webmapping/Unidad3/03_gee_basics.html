<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Funciones básicas en GEE</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mg. José A. Lastra  Matías Olea" />
    <link href="libs/remark-css/fc.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Funciones básicas en GEE
## Curso: Introducción al análisis espacial y web-mapping <br>con Google Earth Engine y R Shiny<br>
### Mg. José A. Lastra <br>Matías Olea<br>
### Laboratorio Geo-Información y Percepción Remota
### 21/12/2020

---

background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%




---
# Importando una colección de datos

--
- Dentro de GEE disponemos de una gran cantidad de información, que está agrupada en colecciones.
- Cada colección corresponde a un producto diferente, ya sea satelital, modelo climático, etc.
- Para llamar colecciones, vamos a considerar una estructura mínima similar a lo siguiente:

--

```js
var imageCollection = ee.ImageCollection('NOMBRE/PRODUCTO')
```


&lt;script type="text/javascript"&gt;
var imageCollection = ee.ImageCollection('NOMBRE/PRODUCTO')
&lt;/script&gt;

- De esta forma importaremos la colección de datos completa, y podemos imprimir la colección en la consola usando `print()`

---
# Filtrando una colección

--
- Para poder visualizar solo la información que nos interesa o filtrar en base a criterios específicos (región de interés ,fechas, cobertura nubosa, etc.)

--
- GEE dispone de varias formas que podemos emplear como: *filter()*, *filterBounds()*,
*filterDate()*, etc.

--
- Filtrar la información nos permitirá poder imprimir en la consola los resultados e inspeccionarlos de forma más simple.

--
- Considere que en consola solo se pueden imprimir hasta 5000 elementos, después de eso los resultados no se pueden ver en la consola, pero si estarán disponibles para analizar.


---
class: middle, center
## Filtrando una colección
&lt;iframe width="800" height="500" src="https://www.youtube.com/embed/fBkl3H3LmXA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
# Creando una imagen desde una colección

--
- Cada colección dispone de diferentes archivos dentro de ella, desde rasters individuales hasta archivos multibanda.

--
- Podemos crear una imagen empleando uno de los archivos dentro de la colección o podemos crear reducciones de toda la colección (cosa que veremos más adelante)

--
- *Importante*: Debemos tener en cuenta como se almacena la información y los nombres de las capas de información para seleccionar.

---
class: middle, center
## Creando una imagen desde una colección
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/F8lwQSJdRmA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
# Exportando imagen desde GEE

--
- Al procesar la información dentro de GEE, podemos optimizar el uso de espacio y descargar solo los resultados o solo la imagen acotada a una zona de nuestro interés.

--
- Para exportar podemos hacerlo a un asset (dentro de la memoria de GEE), a Google Cloud o a Google Drive.

-- 
- En el caso de Google Cloud debemos considerar pago por uso de almacenamiento.

--
- En el caso de Google Drive y assets estamos limitados al espacio de cada plataforma.

---
class: middle, center
## Exportando imagen desde colección
&lt;iframe width="800" height="500" src="https://www.youtube.com/embed/0G4OPNWVk30" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;


---
# Clasificación de imágenes

--
- Los procesos de clasificación se basan en asignar un *conjunto de píxeles en la imagen digital a un conjunto de clases*

--
- Responde a la idea de que pueden establecerse límites entre las respuestas espectrales de unos píxeles y otros.

--
- Estos límites son los que definen las clases.

--
- El resultado de una clasificación digital corresponde a un inventario de las categorías objeto de estudio.

--
.center[
![:scale 90%](https://land.copernicus.eu/global/sites/cgls.vito.be/files/images/products/LandCover_global_v2_discrete-and-FCC.png)
]
---
# Métodos de clasificación

--
- Existen múltiples métodos para generar clases:
  * No estadísticos (mínima distancia, paralelepípedos).
  * Estadísticos clásicos (máxima probabilidad).

- Algoritmos basados en inteligencia artificial y machine learning:
    + Redes neuronales
    + Random Forest
    + Support vector machine
    
.center[
![](clasificacion1.png)
]

---
# Consideraciones

--
- Podemos disponer de métodos de clasificación *NO SUPERVISADOS* y *SUPERVISADOS*

--
- En el primer caso necesitaremos definir inicialmente un número base de clases y seleccionar el algoritmo de clasificación para obtener un resultado.

--
- Para el segundo caso, se deben considerar los siguientes pasos:
  + Generación de un conjunto de clases y sus respuestas espectrales características (definición
  digital de las áreas de entrenamiento).
  + Adjudicación de todos los píxel a alguna de las clases (fase de asignación).
  + Comprobación y verificación de resultados.
  
---
# Ahora en GEE

--
- En GEE disponemos de un número importante de funciones dedicadas al aprendizaje de máquinas (ML, Machine Learning en inglés) como ee.Classifier, ee.Clusterer o ee.Reducer. En los ejemplos que utilizaremos a continuación, veremos cómo emplear clasificación no supervisada y supervisada para imágenes multiespectrales.

--
- En el siguiente ejemplo realizaremos una clasificación no supervisada en base imágenes Landsat 8 Level 2 Surface Reflectance; entre 2018-01-01 / 2019-01-01

- Filtraremos a una zona de interés

--


```js
//Clasificación no supervisada
var collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
 .filterDate('2018-01-01', '2019-01-01')
 .filterBounds(geometry);
 print(collection,'archivos disponibles')

```


&lt;script type="text/javascript"&gt;
//Clasificación no supervisada
var collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
 .filterDate('2018-01-01', '2019-01-01')
 .filterBounds(geometry);
 print(collection,'archivos disponibles')

&lt;/script&gt;

---
class: middle, center
## Clasificación No Supervisada
&lt;iframe width="800" height="500" src="https://www.youtube.com/embed/ACNFChigIXA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
# Creando mosaico base

--
- Para trabajar adecuadamente, crearemos un mosaico de la mediana de las bandas espectrales 1 - 7 (Coastal - SWIR2) 

- Añadiremos el resultado a la vista de mapa con una composición en falso color.


```js
// Selección valor mediano de pixel y ajuste a área de estudio.
var composite = collection.select('B1','B2','B3','B4','B5','B6','B7').median().clip(geometry);
// Selección de bandas para visualización.
var result = composite.select('B5', 'B4', 'B3');
Map.addLayer(result, {gain: '0.1, 0.1, 0.1'});

```


&lt;script type="text/javascript"&gt;
// Selección valor mediano de pixel y ajuste a área de estudio.
var composite = collection.select('B1','B2','B3','B4','B5','B6','B7').median().clip(geometry);
// Selección de bandas para visualización.
var result = composite.select('B5', 'B4', 'B3');
Map.addLayer(result, {gain: '0.1, 0.1, 0.1'});

&lt;/script&gt;

---
# Clasificación

Con nuestra imagen a clusterizar ya disponible, los siguientes pasos lógicos a implementar son los siguientes:
- Crear entidades que determinarán dónde encontrar los clusters.
- Iniciar la búsqueda de clusters a partir de esas entidades.
- Entrenar los clusters empleando la información de entrenamiento.
- Aplicar los clusters.

--


```js
//Creación de entidades
var training = composite.sample({
  region: muestra,
  scale: 30,
  seed: 10,
  numPixels: 3000
});
print(training, 'entidades')

```


&lt;script type="text/javascript"&gt;
//Creación de entidades
var training = composite.sample({
  region: muestra,
  scale: 30,
  seed: 10,
  numPixels: 3000
});
print(training, 'entidades')

&lt;/script&gt;

Recuerde definir su región de muestra, sino la selecciona todos los pixeles serán empleados.

---

--
- Con estas entidades, procederemos a entrenar nuestros clusters, aplicarlos sobre nuestro mosaico y visualizarlos en nuestra vista de mapa.

--


```js
// Iniciar clusters y entrenar con información tomada de la muestra
var clusterer = ee.Clusterer.wekaKMeans(8).train(training);
// Clusterizar imagen empleando el objeto clusterer
var clusters_result = composite.cluster(clusterer);
// Visualizar cluster con colores aleatorios
Map.addLayer(clusters_result.randomVisualizer(), {}, 'clusters',false);

```


&lt;script type="text/javascript"&gt;
// Iniciar clusters y entrenar con información tomada de la muestra
var clusterer = ee.Clusterer.wekaKMeans(8).train(training);
// Clusterizar imagen empleando el objeto clusterer
var clusters_result = composite.cluster(clusterer);
// Visualizar cluster con colores aleatorios
Map.addLayer(clusters_result.randomVisualizer(), {}, 'clusters',false);

&lt;/script&gt;

.center[
![:scale 60%](clasificacion2.png)
]

---
# Clasificación supervisada

--
- Como se mencionó anteriormente, para realizar una clasificación supervisada se requiere inicialmente de información conocida del lugar a analizar, ya sea, obtenida mediante campañas de terreno o a partir de fotointerpretación u otra información secundaria. Otro aspecto relevante es el algoritmo empleado para la realización del proceso de clasificación y la selección de la o las imágenes a clasificar.

--
- Haremos uso de imágenes Sentinel 2 (A/B) pertenecientes a la Agencia Espacial Europea (ESA, en inglés), que disponen de 13 bandas espectrales útiles para el mapeo de diferentes elementos tanto terrestres como acuáticos a diferentes resoluciones espaciales.

--
- Filtraremos las imágenes a un área de interés considerando menos de un 15% de nubosidad y que vayan entre septiembre de 2018 y febrero de 2019, generando un mosaico de primavera/verano de la mediana.

---
class: middle, center
## Clasificación Supervisada
&lt;iframe width="800" height="500" src="https://www.youtube.com/embed/bbkNEOweXZU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
# Código para selección

--


```js
//Clasificación supervisada
//    Seleccionar producto
// Indicar el ImageCollection ID
var producto = ee.ImageCollection('COPERNICUS/S2');//Sentinel 2
// Filtrar colección
var producto_filtrado = producto
    // Por área de estudio utilizando polígono de nombre muestra
    .filterBounds(muestra)
    //por rango de fechas
    .filterDate('2018-09-01', '2019-02-28')
    // por cobertura de nubes máxima – Sentinel 2
    .filterMetadata('CLOUDY_PIXEL_PERCENTAGE','less_than', 15);
// ver resultado para filtros aplicados
print("Coleccion seleccionada", producto_filtrado);

```


&lt;script type="text/javascript"&gt;
//Clasificación supervisada
//    Seleccionar producto
// Indicar el ImageCollection ID
var producto = ee.ImageCollection('COPERNICUS/S2');//Sentinel 2
// Filtrar colección
var producto_filtrado = producto
    // Por área de estudio utilizando polígono de nombre muestra
    .filterBounds(muestra)
    //por rango de fechas
    .filterDate('2018-09-01', '2019-02-28')
    // por cobertura de nubes máxima – Sentinel 2
    .filterMetadata('CLOUDY_PIXEL_PERCENTAGE','less_than', 15);
// ver resultado para filtros aplicados
print("Coleccion seleccionada", producto_filtrado);

&lt;/script&gt;

---
# Generando mosaico

--
- Seleccionaremos un conjunto de bandas para realizar nuestro mosaico
- Luego lo añadiremos a la vista de mapa

--


```js
// Definir bandas a seleccionar
var bandas = ['B2','B3','B4','B8','B11','B12'];
var mosaico = producto_filtrado.select(bandas).median();
// ver imagen en mapa:
Map.addLayer( mosaico.clip(muestra), {bands: ['B8', 'B4', 'B3'], min: [0,0,0], max:[2500,2500,2500] } , "S2 B8-B4-B3" );
// centrar en area de estudio
Map.centerObject(muestra);

```


&lt;script type="text/javascript"&gt;
// Definir bandas a seleccionar
var bandas = ['B2','B3','B4','B8','B11','B12'];
var mosaico = producto_filtrado.select(bandas).median();
// ver imagen en mapa:
Map.addLayer( mosaico.clip(muestra), {bands: ['B8', 'B4', 'B3'], min: [0,0,0], max:[2500,2500,2500] } , "S2 B8-B4-B3" );
// centrar en area de estudio
Map.centerObject(muestra);

&lt;/script&gt;

--
Con nuestro mosaico listo, crearemos regiones de entrenamiento considerando las clases: agua, bosque, urbano, pradera, cultivos, suelo y nieve.


---
# Puntos de referencia

--
- Con nuestras entidades de entrenamiento listas, las fusionaremos en una sola entidad

--


```js
// Unir categorias
var clases = agua.merge(bosque).merge(urbano).merge(cultivos).merge(suelo).merge(nieve);
print(clases, 'clases')
```


&lt;script type="text/javascript"&gt;
// Unir categorias
var clases = agua.merge(bosque).merge(urbano).merge(cultivos).merge(suelo).merge(nieve);
print(clases, 'clases')
&lt;/script&gt;

---
# Entrenamiento y validación

--
- Separaremos los datos creados en dos conjuntos uno de entrenamiento y uno de validación.

--
- Para esto crearemos una columna adicional con la función *randomColumn()* en nuestro *FeatureCollection* que contenga números aleatorios para luego filtrar los conjuntos.

--
- Y haremos la extracción de información en nuestro mosaico para cada punto de entrenamiento generado.

--


```js
var seed = 100;
var clases = clases.randomColumn('random', seed);
print(clases,'clases');
//muestrear clases en la imagen de entrada para obtener información de entrenamiento
var training_data = mosaico.clip(muestra).sampleRegions({
  collection: clases,
  properties: ['random','landcover'],
  scale: 10
});
// Separación entre Entrenamiento y validación. Identificar umbral de separación
var training = training_data.filterMetadata('random', 'less_than', 0.7);
var testing = training_data.filterMetadata('random', 'not_less_than',0.7);

```


&lt;script type="text/javascript"&gt;
var seed = 100;
var clases = clases.randomColumn('random', seed);
print(clases,'clases');
//muestrear clases en la imagen de entrada para obtener información de entrenamiento
var training_data = mosaico.clip(muestra).sampleRegions({
  collection: clases,
  properties: ['random','landcover'],
  scale: 10
});
// Separación entre Entrenamiento y validación. Identificar umbral de separación
var training = training_data.filterMetadata('random', 'less_than', 0.7);
var testing = training_data.filterMetadata('random', 'not_less_than',0.7);

&lt;/script&gt;

---
# Random Forest (Tumer &amp; Ghosh, 1996)

--
- Ahora usaremos los datos de entrenamiento para crear nuestra clasificación  y añadiremos el resultado a nuestro mapa.

--


```js
// Clasificación RF 
var classifier = ee.Classifier.randomForest(10).train(training,'landcover');
// Clasificar imagen
var classified = mosaico.clip(muestra).classify(classifier);

```


&lt;script type="text/javascript"&gt;
// Clasificación RF 
var classifier = ee.Classifier.randomForest(10).train(training,'landcover');
// Clasificar imagen
var classified = mosaico.clip(muestra).classify(classifier);

&lt;/script&gt;

--


```js
// Definir paleta de colores
var paleta = [
  '#167dd6', // agua (0)  
  '#42af0c', // bosque (1)
  '#fae907', // urbano (2)
  '#0bff14', // cultivos (3)
  '#b77e36', // suelo (4)
  '#bf04c2' // nieve (5)
];
// Despliegue de resultado
Map.addLayer(classified, {min: 0, max: 5, palette: paleta}, 'Clasificación resultante');

```


&lt;script type="text/javascript"&gt;
// Definir paleta de colores
var paleta = [
  '#167dd6', // agua (0)  
  '#42af0c', // bosque (1)
  '#fae907', // urbano (2)
  '#0bff14', // cultivos (3)
  '#b77e36', // suelo (4)
  '#bf04c2' // nieve (5)
];
// Despliegue de resultado
Map.addLayer(classified, {min: 0, max: 5, palette: paleta}, 'Clasificación resultante');

&lt;/script&gt;

---
class: middle, center
![:scale 95%](clasificacion3.png)

---
# Validación de la clasificación

--
El paso final del toda clasificación supervisada consiste en evaluar la precisión del proceso.

--
- Consideraremos en este caso la precisión general del conjunto de entrenamiento y también calcularemos la precisión del conjunto de validación.

--


```js
classifier.confusionMatrix());
print('RF precisión general entrenamiento: ', classifier.confusionMatrix().accuracy());
/// Generación de matriz de confusión y resultados
var validation = testing.classify(classifier);
var errorMatrix = validation.errorMatrix('landcover', 'classification');
print('Matriz de Confusión validación:', errorMatrix);
print('Exactitud General validación:', errorMatrix.accuracy());

```


&lt;script type="text/javascript"&gt;
classifier.confusionMatrix());
print('RF precisión general entrenamiento: ', classifier.confusionMatrix().accuracy());
/// Generación de matriz de confusión y resultados
var validation = testing.classify(classifier);
var errorMatrix = validation.errorMatrix('landcover', 'classification');
print('Matriz de Confusión validación:', errorMatrix);
print('Exactitud General validación:', errorMatrix.accuracy());

&lt;/script&gt;

---
class: middle, center
![](clasificacion4.png)

---
background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "zenburn",
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
