<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lectura y visualización básica de datos en RStudio</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mg. José A. Lastra  Matías Olea" />
    <meta name="date" content="2020-02-12" />
    <link href="libs/remark-css/fc.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Lectura y visualización básica de datos en RStudio
## Curso: Introducción al análisis espacial y web-mapping <br>con Google Earth Engine y R Shiny<br>
### Mg. José A. Lastra <br>Matías Olea<br>
### Laboratorio Geo-Información y Percepción Remota
### 02/12/2020

---

background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%




---
# Recordando a Google Earth Engine

--
- Google Earth Engine (GEE) es una plataforma basada en la nube para el análisis geoespacial a escala planetaria que ofrece las capacidades computacionales masivas de Google permitiendo abordar una variedad de problemas sociales de alto impacto, incluyendo deforestación, sequía, desastres, enfermedades, seguridad alimentaria, gestión del agua, monitoreo del clima y protección del medio ambiente (Gorelick *et al.*, 2017)

--
- Nosotros haremos uso de la consola online que funciona en base a JavaScript.

--
- Lo primero será abrir el [(https://code.earthengine.google.com/)](https://code.earthengine.google.com/), conviene utilizar Google Chrome de preferencia ya que funciona mejor que en otros navegadores web.

--
- Usemos la consola

--

```js
print('Hola Mundo!');
```


&lt;script type="text/javascript"&gt;
print('Hola Mundo!');
&lt;/script&gt;

--
- Podemos agregar comentarios usando *//*

---
# Tipos de datos

--
-**Strings**: Variables de tipo textos o cadenas de caracteres, se utilizan las comillas simples o dobles para definir una cadena.


```js
// Usamos comillas simples o dobles para crear un string
var saludoString = 'Hola Mundo!!';
print( saludoString );
```


&lt;script type="text/javascript"&gt;
// Usamos comillas simples o dobles para crear un string
var saludoString = 'Hola Mundo!!';
print( saludoString );
&lt;/script&gt;

- **Importante**: Tenga en cuenta que las variables se definen utilizando **var**


--
-**Números**: En las variables podemos almacenar números de distinta longitud y precisión.


```js
// Asignamos un número a una variable
var numero = 38;
print('El valor es:', numero);
```


&lt;script type="text/javascript"&gt;
// Asignamos un número a una variable
var numero = 38;
print('El valor es:', numero);
&lt;/script&gt;


--
- **Listas**: Las listas las definimos con corchetes [ ]. En GEE son útiles para realizar selecciones de elementos y podemos almacenar números, caracteres u otros elementos.


```js
// Lista de números
var listDeNumeros = [0, 1, 1, 2, 3, 5];
print('Lista de Números:', listDeNumeros);
// Lista de strings.
var listDeStrings = ['a', 'b', 'c', 'd'];
print('Lista de strings:', listDeStrings);
```


&lt;script type="text/javascript"&gt;
// Lista de números
var listDeNumeros = [0, 1, 1, 2, 3, 5];
print('Lista de Números:', listDeNumeros);
// Lista de strings.
var listDeStrings = ['a', 'b', 'c', 'd'];
print('Lista de strings:', listDeStrings);
&lt;/script&gt;

---

--
- **Objetos**: En JavaScript los objetos son diccionarios de pares **clave: valor**. Para crear un objeto (o diccionario) se utilizan las llaves **{ }**. Útil en procesos como creación de parámetros de visualización o exportación de elementos 


```js
// Usamos las llaves {} para hacer un diccionario de pares clave:valor
var object = {
  foo: 'bar',
  baz: 38,
  stuff: ['Algo', 'eso', 'otro más']
};
print('Diccionario:', object);

// Para acceder al valor de un diccionario se utiliza la clave y los corchetes [ ].
print('Imprime la clave foo:', object['foo']);
// También se puede acceder utilizando la notación con punto.
print('Print stuff:', object.stuff);
```


&lt;script type="text/javascript"&gt;
// Usamos las llaves {} para hacer un diccionario de pares clave:valor
var object = {
  foo: 'bar',
  baz: 38,
  stuff: ['Algo', 'eso', 'otro más']
};
print('Diccionario:', object);

// Para acceder al valor de un diccionario se utiliza la clave y los corchetes [ ].
print('Imprime la clave foo:', object['foo']);
// También se puede acceder utilizando la notación con punto.
print('Print stuff:', object.stuff);
&lt;/script&gt;

---
background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "zenburn",
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
