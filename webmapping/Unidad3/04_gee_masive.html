<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Análisis masivo en GEE</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mg. José A. Lastra  Matías Olea" />
    <link href="libs/remark-css/fc.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Análisis masivo en GEE
## Curso: Introducción al análisis espacial y web-mapping <br>con Google Earth Engine y R Shiny<br>
### Mg. José A. Lastra <br>Matías Olea<br>
### Laboratorio Geo-Información y Percepción Remota
### 20/12/2020

---

background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%




---
# Funciones

--
- Dentro de la sección *Docs* de GEE usted tiene a disposición funciones específicas para trabajar con imágenes y con colecciones de imágenes, dependiendo de cuál sea el análisis a realizar: funciones booleanas, matemáticas, transformaciones, análisis espectral, entre otros.

--
- Para aplicar masivamente un análisis nomralmente se recurre al uso de ciclos

--
- *Importante*: En nuestro code editor se recomienda evitar a toda costa el uso convencional de ciclos; debido a que esto trae la operación al explorador y puede generar errores de funcionamiento

---
# Función map()

--
- En GEE se dispone de la función *map()* para lograr el procesamiento masivo de datos (colecciones de imágenes, geometrías, etc.)

--
- La función *map()* envía automáticamente la operación a los servidores de Google para ser paralelizado permitiendo tener resultados en segundos

---
# Usando map sobre una colección de imágenes

--
- Usaremos el producto *Landsat 8 de nivel 2* y filtraremos una zona de interés considerando todas las imágenes disponibles en nuestra zona.

--
- *Importante*: recuerde que puede agregar más filtros: nubosidad, calidad de la imagen, etc.

--


```js
//Funciones avanzadas de imágenes satelitales
//Carga colección Landsat 8 (SR)
var l8collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
          .filterBounds(geometry);
print(l8collection,'colección landsat');

```


&lt;script type="text/javascript"&gt;
//Funciones avanzadas de imágenes satelitales
//Carga colección Landsat 8 (SR)
var l8collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
          .filterBounds(geometry);
print(l8collection,'colección landsat');

&lt;/script&gt;

--
- Crearemos una función que solo considere los valores de información asociados a *clear terrain* dentro de la escena, según el manual de los productos landsat de nivel 2 y su banda QA [Landsat Product Guide Colección 1 Level 2, p11](https://prd-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/atoms/files/LSDS-1368_L8_C1-LandSurfaceReflectanceCode-LASRC_ProductGuide-v3.pdf) 
---
# Construyendo una función

- En este caso necesitaremos la banda de nombre *pixel_qa*


```js
// Crea la función
var maskClouds = function(image){//indica que la función se realizará sobre una imagen
  // crea una nueva imagen desde la banda pixel_qa de cada archivo en la colección
  var pixel_qa = image.select('pixel_qa');
  var cl1 = pixel_qa.eq(322);
  var cl2 = pixel_qa.eq(386);
  var cl3 = pixel_qa.eq(834);
  var cl4 = pixel_qa.eq(898);
  var cl5 = pixel_qa.eq(1346);
  var mask = cl1.or(cl2).or(cl3).or(cl4).or(cl5);
  //actualiza información que se mantendrá en el dato de salida por pixel
  return image.updateMask(mask);   
};
```


&lt;script type="text/javascript"&gt;
// Crea la función
var maskClouds = function(image){//indica que la función se realizará sobre una imagen
  // crea una nueva imagen desde la banda pixel_qa de cada archivo en la colección
  var pixel_qa = image.select('pixel_qa');
  var cl1 = pixel_qa.eq(322);
  var cl2 = pixel_qa.eq(386);
  var cl3 = pixel_qa.eq(834);
  var cl4 = pixel_qa.eq(898);
  var cl5 = pixel_qa.eq(1346);
  var mask = cl1.or(cl2).or(cl3).or(cl4).or(cl5);
  //actualiza información que se mantendrá en el dato de salida por pixel
  return image.updateMask(mask);   
};
&lt;/script&gt;

---
# Aplicando función

--
- Ahora usaremos *map()* para aplicar nuestra función a todas las bandas dentro de la colección de imágenes.


```js
// usando map para la colección de imágenes
var l8masked = l8collection.map(maskClouds);
```


&lt;script type="text/javascript"&gt;
// usando map para la colección de imágenes
var l8masked = l8collection.map(maskClouds);
&lt;/script&gt;


```js
// Visualización de resultados
var visParams = {bands: ['B4','B3','B2'], min: 150, max: 2000}; //crear parámetros de visualización de datos
Map.addLayer(ee.Image(l8masked.first()), visParams, 'enmascarada');
Map.addLayer(ee.Image(l8collection.first()), visParams, 'original');
```


&lt;script type="text/javascript"&gt;
// Visualización de resultados
var visParams = {bands: ['B4','B3','B2'], min: 150, max: 2000}; //crear parámetros de visualización de datos
Map.addLayer(ee.Image(l8masked.first()), visParams, 'enmascarada');
Map.addLayer(ee.Image(l8collection.first()), visParams, 'original');
&lt;/script&gt;

---
class: middle
.center[
![:scale 95%](GEE1.png)
]

---
# Aplicando varias funciones

--
- Dentro de nuestra código podemos emplear una sola función que ejecute todos los análisis y procesamientos que requerimos y aplicarlos de una sola vez.

--
- La desventaja de esto, es que si algo falla en el código es más difícil de encontrar.

--
- Por esta razón, lo recomendable es modularizar los procesos y ponerlos en funciones diferentes.

--
- A continuación crearemos una función para cortar la imagen a un área de interés. Creada a partir de las herramientas de geometría.



```js
//función para cortar imágenes al área de estudio
var crop = function (image){
  var crop1 = image.clip(roi);
  return crop1;
};
// usando map para la colección de imágenes
var l8masked = l8collection.map(maskClouds).map(crop);
```


&lt;script type="text/javascript"&gt;
//función para cortar imágenes al área de estudio
var crop = function (image){
  var crop1 = image.clip(roi);
  return crop1;
};
// usando map para la colección de imágenes
var l8masked = l8collection.map(maskClouds).map(crop);
&lt;/script&gt;

---
# Agregando información a la colección

--
- Además de la información que viene por defecto en el producto que estemos empleando en GEE, el usuario puede crear nueva información a partir de una función de cálculo (ej. NDVI, EVI, temperatura, etc.) y agregarla a dentro de la colección para que forme parte de un posterior análisis o descarga.

--
- Realizaremos el cálculo del Índice de diferencia normalizado de vegetación (*NDVI*, en inglés), empleando la información de nuestra colección de nombre *l8masked*

--
- *Importante:* podemos generar una función empleando operadores matemáticos directos o a partir de funciones disponibles dentro de GEE. El resultado es el mismo.


```js
// Crear función para cálculo de NDVI versión simple
var NDVI = function(img){
  return img.addBands(img.normalizedDifference(['B5','B4']).rename('NDVI'));
};
// Crear función para cálculo de NDVI versión con operadores matemáticos
var NDVI2 = function(img){
  return img.addBands(img.select('B5').subtract(img.select('B4'))
            .divide(img.select('B5').add(img.select('B3'))));
};
```


&lt;script type="text/javascript"&gt;
// Crear función para cálculo de NDVI versión simple
var NDVI = function(img){
  return img.addBands(img.normalizedDifference(['B5','B4']).rename('NDVI'));
};
// Crear función para cálculo de NDVI versión con operadores matemáticos
var NDVI2 = function(img){
  return img.addBands(img.select('B5').subtract(img.select('B4'))
            .divide(img.select('B5').add(img.select('B3'))));
};
&lt;/script&gt;

---

--
- Apliquemos la nueva función y revisemos la  información de una de las imágenes en nuestra nueva colección.

--


```js
// Cálculo deNDVI para la colección completa
var l8ndvi = l8masked.map(NDVI);
// imprimir una imagen en la consola
print(ee.Image(l8ndvi.first()));

```


&lt;script type="text/javascript"&gt;
// Cálculo deNDVI para la colección completa
var l8ndvi = l8masked.map(NDVI);
// imprimir una imagen en la consola
print(ee.Image(l8ndvi.first()));

&lt;/script&gt;

.center[
![](GEE2.png)
]

---
# Agregaciones temporales (Reducers)

--
- Las reducciones (*reducers*) se utilizan para agregar información dentro de una colección a nivel temporal y espacial.

--
- Estas agregaciones pueden ser de diferentes estadísticas y tipos, disponiendo de elementos como suma o conteo hasta regresiones lineales y otros.

.center[
![](https://developers.google.com/earth-engine/images/Reduce_ImageCollection.png)
]
.center[
.footnote[[Google Developers, 2019](https://developers.google.com/earth-engine/guides/reducers_image_collection)]
]

---
# Estadísticas en el tiempo: Agregaciones temporales

--
- Un ejemplo sencillo de agregación temporal es el NDVI acumulado.

--
- Para esto usaremos toda nuestra área de interés actual y emplearemos las funciones *reduce()* y *ee.Reducer()*


```js
//Suma temporal de NDVI
var suma = l8ndvi.select('NDVI').reduce(ee.Reducer.sum());// también se puede escribir l8ndvi.select(‘NDVI’).sum()
print(suma,'suma: agregación');
```


&lt;script type="text/javascript"&gt;
//Suma temporal de NDVI
var suma = l8ndvi.select('NDVI').reduce(ee.Reducer.sum());// también se puede escribir l8ndvi.select(‘NDVI’).sum()
print(suma,'suma: agregación');
&lt;/script&gt;

Visualicemos


```js
//Parámetros de visualización NDVI
var ndviParams = {min: 4, max: 50, palette: ['#d73027','#f46d43','#fdae61','#fee08b',
'#d9ef8b','#a6d96a','#66bd63','#1a9850']};
Map.addLayer(suma,ndviParams,'NDVI sum')

```


&lt;script type="text/javascript"&gt;
//Parámetros de visualización NDVI
var ndviParams = {min: 4, max: 50, palette: ['#d73027','#f46d43','#fdae61','#fee08b',
'#d9ef8b','#a6d96a','#66bd63','#1a9850']};
Map.addLayer(suma,ndviParams,'NDVI sum')

&lt;/script&gt;

---
class: middle, center

![:scale 95%](GEE3.png)
---
# Estadísticas de zona: agregaciones espaciales

--
- Una forma simple de calcular la estadística de un área es creando una geometría y calculando un estadístico sobre la misma.

--
- Para este ejemplo calcularemos el promedio de un área de interés dentro de nuestra suma de NDVI


```js
//Estadísticas de zona
// valor promedio para polígono de interés
var mean = suma.reduceRegion({
  geometry: zona,
  reducer: ee.Reducer.mean(),
  scale: 30 // resolución de archivos Landsat
});
print(mean);
```


&lt;script type="text/javascript"&gt;
//Estadísticas de zona
// valor promedio para polígono de interés
var mean = suma.reduceRegion({
  geometry: zona,
  reducer: ee.Reducer.mean(),
  scale: 30 // resolución de archivos Landsat
});
print(mean);
&lt;/script&gt;

---
- Para calcular las estadícticas de zona en áreas específicas, cargue en sus *Assets* el archivo de nombre *zonas.zip*

--
- Luego lo importaremos a nuestro script y calcularemos el valor promedio para todos los polígonos en nuestro asset


```js
//Para varios polígonos
var means = suma.reduceRegions({
  collection: zonas,
  reducer: ee.Reducer.mean(),
  scale: 30 // resolución de archivos Landsat
});
print(means,'means values');

```


&lt;script type="text/javascript"&gt;
//Para varios polígonos
var means = suma.reduceRegions({
  collection: zonas,
  reducer: ee.Reducer.mean(),
  scale: 30 // resolución de archivos Landsat
});
print(means,'means values');

&lt;/script&gt;

---
# Exportación de información tabular

--
- La información extraída a los polígonos puede ser exportada al igual que las imágenes, para ser analizada posteriormente en otro programa o plataforma.


```js
//descarga de datos
// Selección de columnas
var salida = means.select(['Name','mean'],null,false);
// Table to Drive Export Example
Export.table.toDrive({
  collection: salida,
  description: 'ejemplo_descarga_csv',
  fileFormat: 'CSV'
});   

```


&lt;script type="text/javascript"&gt;
//descarga de datos
// Selección de columnas
var salida = means.select(['Name','mean'],null,false);
// Table to Drive Export Example
Export.table.toDrive({
  collection: salida,
  description: 'ejemplo_descarga_csv',
  fileFormat: 'CSV'
});   

&lt;/script&gt;

--
- Esto activará la opción de descarga en la pestaña *Task* donde debe oprimir *Run* para iniciar el proceso de exportación del archivo.

---
# Series de tiempo

--
- GEE tiene disponibles un gran número de datasets que disponen de información estandarizada en el tiempo muy útil para análisis de cambios y dinámica espacio-temporal. 

--
- Por ejemplo:
  + GIMMS NDVI (Jul 1981 – Dec 2013), 
  + Hybrid Coordinate Ocean Model (Oct 1992 – actualidad), 
  + MOD13Q1/ MYD13Q1 Versión 6 Vegetation Indices 16-Day L3 Global 250 m (Feb 18, 2000 - actualidad), 
  + Landsat 5/7/8 (Ene 1984 - actualidad)
  
--
- Además de información climática de diferentes modelos


---
# Extracción de series

--
- Para este ejercicio aplicaremos algunas herramientas ya usadas: (i) uso de *map()*, (ii) agregación espacial y temporal y (iii) unión de colecciones de datos

--
- Landsat 5 y 8 L2 (Surface reflectance) y calcularemos el Moisture Stress Index (MSI, [Welikhe et al., 2017](https://www.longdom.org/open-access/estimation-of-soil-moisture-percentage-using-landsatbased-moisturestress-index-2469-4134-1000200.pdf)) para todas las imágenes disponibles

--
- Para filtrar las colecciones haremos uso de una geometría y consideraremos todas las escenas que tengan 30% o menos de cobertura nubosa.

--
- *Importante*: se puede considerar un umbral más alto o más bajo dependiendo de la zona de estudio y la cantidad de pérdida de datos.

---
# Importando colecciones de datos


--


```js
//Series de tiempo básicas
//colecciones de imágenes
var landsat8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR")
.filterBounds(muestra)
.filter(ee.Filter.lt('CLOUD_COVER',30));

var landsat5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
    .filterBounds(muestra)
    .filter(ee.Filter.lt('CLOUD_COVER',30));

```


&lt;script type="text/javascript"&gt;
//Series de tiempo básicas
//colecciones de imágenes
var landsat8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR")
.filterBounds(muestra)
.filter(ee.Filter.lt('CLOUD_COVER',30));

var landsat5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
    .filterBounds(muestra)
    .filter(ee.Filter.lt('CLOUD_COVER',30));

&lt;/script&gt;


--
Debido a que ambos sensores poseen distinto número de bandas, realizaremos un cambio en los nombres de las mismas para que posteriormente sea más sencillo crear la función de cálculo de nuestro índice.

---
# Renombrando bandas

--
- Seleccionaremos solo las bandas de interés incluída la banda *pixel_qa* para trabajar nuestras colecciones


```js
// Renombrar bandas
var landsat8k = landsat8.select(
                ['B1', 'B2', 'B3','B4', 'B5', 'B6','B7', 'pixel_qa', 'radsat_qa'], // viejos nombres
                ['aerosol', 'azul', 'verde','rojo', 'nir', 'swir1','swir2', 'pixel_qa','radsat_qa']);//nuevos nombres
var landsat5k = landsat5.select(
                ['B1', 'B2', 'B3','B4', 'B5', 'B6','B7', 'pixel_qa','radsat_qa'], // viejos nombres
                ['azul', 'verde','rojo', 'nir', 'swir1', 'tir1','swir2', 'pixel_qa','radsat_qa']); // nuevos nombres

```


&lt;script type="text/javascript"&gt;
// Renombrar bandas
var landsat8k = landsat8.select(
                ['B1', 'B2', 'B3','B4', 'B5', 'B6','B7', 'pixel_qa', 'radsat_qa'], // viejos nombres
                ['aerosol', 'azul', 'verde','rojo', 'nir', 'swir1','swir2', 'pixel_qa','radsat_qa']);//nuevos nombres
var landsat5k = landsat5.select(
                ['B1', 'B2', 'B3','B4', 'B5', 'B6','B7', 'pixel_qa','radsat_qa'], // viejos nombres
                ['azul', 'verde','rojo', 'nir', 'swir1', 'tir1','swir2', 'pixel_qa','radsat_qa']); // nuevos nombres

&lt;/script&gt;

---
# Quality assesment

--
- A continuación, emplearemos una función simplificada de limpieza considerando solo los uno de los valores *clear terrain* para los dos sensores.

--


```js
// Enmascarar nubes y sombras de nubes
//Landsat 8
var l8Clouds = function(image){
  var pixel_qa = image.select('pixel_qa');
  //actualiza información que se mantendrá en el dato de salida por pixel
  return image.updateMask(pixel_qa.eq(322));   
};

//Landsat 5
var l5Clouds = function(image){
  var pixel_qa = image.select('pixel_qa');
  //actualiza información que se mantendrá en el dato de salida por pixel
  return image.updateMask(pixel_qa.eq(66));   
};

```


&lt;script type="text/javascript"&gt;
// Enmascarar nubes y sombras de nubes
//Landsat 8
var l8Clouds = function(image){
  var pixel_qa = image.select('pixel_qa');
  //actualiza información que se mantendrá en el dato de salida por pixel
  return image.updateMask(pixel_qa.eq(322));   
};

//Landsat 5
var l5Clouds = function(image){
  var pixel_qa = image.select('pixel_qa');
  //actualiza información que se mantendrá en el dato de salida por pixel
  return image.updateMask(pixel_qa.eq(66));   
};

&lt;/script&gt;


--
*Importante:* la aplicación de quality assesment sobre nuestros datos, dependerá de la zona, el nivel de rigurosidad que queamos en la limpieza, la cantidad de información que estemos dispuesto a perder, entre muchos otros factores.

---
# Creando función para el índice

--
- Crearemos el MSI y lo agregaremos a nuestra colección


```js
////Función para calcular msi
var MSI = function(image) {
  var msi = image.select('swir1').divide(image.select('nir')).rename('MSI');//calcula índice
  return image.addBands(msi);//agrega índice a la colección de bandas
};

```


&lt;script type="text/javascript"&gt;
////Función para calcular msi
var MSI = function(image) {
  var msi = image.select('swir1').divide(image.select('nir')).rename('MSI');//calcula índice
  return image.addBands(msi);//agrega índice a la colección de bandas
};

&lt;/script&gt;

Ahora aplicaremos las funciones a ambas colecciones y las fusionaremos en una sola, ordenándolas de la más reciente a la más antigua.



```js
//aplicando funciones a ambas colecciones
var L8sr = landsat8k
.map(l8Clouds)
.map(MSI)
.sort('system:time_start', false);
var L5sr = landsat5k
.map(l5Clouds)
.map(MSI)
.sort('system:time_start', false);
//fusión de colecciones L5 y L8
var collection = L5sr.merge(L8sr)
.sort('system:time_start',false);
//Productos disponibles entre ambas colecciones
print(collection,'dataset final');
```


&lt;script type="text/javascript"&gt;
//aplicando funciones a ambas colecciones
var L8sr = landsat8k
.map(l8Clouds)
.map(MSI)
.sort('system:time_start', false);
var L5sr = landsat5k
.map(l5Clouds)
.map(MSI)
.sort('system:time_start', false);
//fusión de colecciones L5 y L8
var collection = L5sr.merge(L8sr)
.sort('system:time_start',false);
//Productos disponibles entre ambas colecciones
print(collection,'dataset final');
&lt;/script&gt;

---
# Visualizando índice

--
- Añadiremos la información al mapa para poder inspeccionar los valores.


```js
//visualización de datos
var MSI_view= collection.first().select('MSI');
print(MSI_view,'MSI reciente');
//Display MSI más reciente
//paleta
var palette = ["#003c30","#01665e","#35978f","#80cdc1","#c7eae5","#f5f5f5",
"#f6e8c3","#dfc27d","#bf812d","#8c510a","#543005"];
//agregar al mapa  
Map.addLayer(MSI_view,{min: 0, max: 2, palette: palette},'MSI Test');
```


&lt;script type="text/javascript"&gt;
//visualización de datos
var MSI_view= collection.first().select('MSI');
print(MSI_view,'MSI reciente');
//Display MSI más reciente
//paleta
var palette = ["#003c30","#01665e","#35978f","#80cdc1","#c7eae5","#f5f5f5",
"#f6e8c3","#dfc27d","#bf812d","#8c510a","#543005"];
//agregar al mapa  
Map.addLayer(MSI_view,{min: 0, max: 2, palette: palette},'MSI Test');
&lt;/script&gt;

---
# Creación de serie de tiempo

--
- Ahora crearemos una geometría en algún sitio de interés y mostraremos el gráfico en la consola


```js
// Gráfico de serie de tiempo.
var tempTimeSeries = ui.Chart.image.seriesByRegion(//gráfico utilizando región de referencia
    collection, geom, ee.Reducer.median(), 'MSI', 30, 'system:time_start', 'label') //agregación de mediana
        .setChartType('ScatterChart')//tipo de gráfico
        .setOptions({//opciones
          title: 'MSI',//título de gráfico
          vAxis: {title: 'MSI median'},//eje y
          
          lineWidth: 1,
          pointSize: 2.5,
          series: {
            0: {color: '#4e00f4'}, 
}});
// Display.
print(tempTimeSeries, 'serie de tiempo ejemplo');
```


&lt;script type="text/javascript"&gt;
// Gráfico de serie de tiempo.
var tempTimeSeries = ui.Chart.image.seriesByRegion(//gráfico utilizando región de referencia
    collection, geom, ee.Reducer.median(), 'MSI', 30, 'system:time_start', 'label') //agregación de mediana
        .setChartType('ScatterChart')//tipo de gráfico
        .setOptions({//opciones
          title: 'MSI',//título de gráfico
          vAxis: {title: 'MSI median'},//eje y
          
          lineWidth: 1,
          pointSize: 2.5,
          series: {
            0: {color: '#4e00f4'}, 
}});
// Display.
print(tempTimeSeries, 'serie de tiempo ejemplo');
&lt;/script&gt;


--
*Importante:* si nuestra serie tiene más de 5000 elementos no la podremos mostrar de forma directa en la consola.

---
class: middle, center
![](GEE4.png)
---
background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "zenburn",
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
