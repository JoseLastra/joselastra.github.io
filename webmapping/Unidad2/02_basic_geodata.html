<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Aplicaciones con geo-datos: Parte I</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mg. José A. Lastra  Matías Olea" />
    <link href="libs/remark-css/fc.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Aplicaciones con geo-datos: Parte I
## Curso: Introducción al análisis espacial y web-mapping <br>con Google Earth Engine y R Shiny<br>
### Mg. José A. Lastra <br>Matías Olea<br>
### Laboratorio Geo-Información y Percepción Remota
### 14/12/2020

---

background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%




---

Librerías utilizadas en esta sesión


```r
library(shiny)
library(tidyverse)
library(sf)
library(rgdal)
library(leaflet)
```

--
A continuación, dispone de todas las líneas de código para seguir el tutorial de manera complementaria.

---
class: middle, center

&lt;iframe width="800" height="500" src="https://www.youtube.com/embed/rzcdsb22l48" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
# Estructurando nuestra app

--
- De momento, hemos utilizado la página fluída (fluidPage) en nuestra aplicación inicial con datos.

--
- Una mejor alternativa es el uso de las páginas de tipo bootstrap (bootstrapPage) ya que:
  + Se integra eficientemente con JavaScript (sobre todo si posteriormente personalizamos nuestra página)
  + Compatibe con la mayoría de los navegadores
  + Responsive

---
# Diagrama general

--
- Primero configuraremos el cuerpo general del script y para poder emplear nuestro mapa a página completa emplearemos *tags*

--
- Nuestro mapa base lo haremos con *leatletOutput()*

--
- Leeremos nuestras capas de información vectorial y la reproyectaremos de inmediato para operar en leaflet

---

```r
library(shiny)
library(tidyverse)
library(sf)
library(rgdal)
library(leaflet)
########### UI #######################
ui &lt;- bootstrapPage(
  tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
  leafletOutput('map', width = "100%", height = "100%")
)
############SERVER###################
server &lt;- function(input, output, session) {
  #Load data
  valpo &lt;- read_sf('censoINE_Valparaiso2017.gpkg') %&gt;% st_transform(4326)
  ## rendering base map
  output$map &lt;- renderLeaflet({
    leaflet() %&gt;% addProviderTiles(providers$CartoDB.DarkMatter) %&gt;% 
      fitBounds(lng1 =-109.5 ,lat1 =-33.96 ,lng2 =-69.9 ,lat2 = -26.29) #ajustar extensión inicial del mapa
  })
}
##########Compile####################
shinyApp(ui,server)
```

--
- *fitBounds()* nos permite fijar la extensión inicial del mapa base

---
class: middle, center
![:scale 65%](app1.1.png)

---
# Antes de empezar

- Además de utilizar eventos puestos en la UI (sliders, select inputs, acction buttons, etc.), podemos hacer uso de eventos de mapa y objeto para pasarlos por el server.

--
- Los eventos de objeto se configuran así `input$MAPID_OBJCATEGORY_EVENTNAME` donde:
  + MAPID: nombre del mapa;
  + OBJCATEGORY: tipo de elemento para pasaro por el evento reactivo (marker, shape, geojson o topojson);
  + EVENTNAME: reacción al mouse (click, mouseover y mouseout)

--
- Los eventos de mapa se configuran así `input$MAPID_EVENTNAME` donde las opciones de evento disponibles son:
  + Click;
  + Bounds;
  + Zoom;
  + Center;

- Usaremos algunos de estos eventos durante el desarrollo de nuestra aplicación

---
# Incorporando Elementos en la UI

--
- Agregaremos un panel donde pondremos nuestras opciones

--
- Importante conocer esto sobre los paneles y su posición en la página [Más info.](https://leafletjs.com/reference-1.7.1.html#map-pane)

--
- Usaremos un panel que irá sobre nuestro mapa e iremos incorporando opciones en el. 

--

```r
absolutePanel(id="controls",
                style="z-index:500;", top = 90, left = "auto", right = 20, 
                bottom = "auto",
                width = 400, height ="auto",
                class = "panel panel-default"
                )
```

--
- El argumento *style = "z-index:500;"* controla la posición de nuestro panel en nuestra página.

--
- Es importante poner 500 para que el panel esté por sobre nuestro mapa de leaflet.

---
class: middle, center
![:scale 65%](app1.2.png)

---

--
- A continuación, incorporaremos la opción de seleccionar un campo para visualizar en el mapa como información temática.

--
- Es importante considerar que cada elemento en la UI va serparado por una coma y que podemos revisar los elementos disponibles en el siguiente [vínculo](https://shiny.rstudio.com/gallery/widget-gallery.html)

--
- Nuestros input los pondremos en el panel absoluto.

--

```r
absolutePanel(id="controls",
              style="z-index:500;", top = 90, left = "auto", right = 20,bottom = "auto",
              width = 400, height ="auto",class = "panel panel-default",
              selectInput(inputId = "campo",label = 'Seleccione un campo de la lista',
                          choices = c("T_HOM","T_MUJ","T_POB","T_VIV"), selected = "T_POB")
              )
```

--
- Puede usar diferentes elementos para definir las opciones (vectores, listas, caracteres, números, etc.)

--
- Lo importante es considerar la operación posterior en el server.

---
class: middle, center
![:scale 95%](app1.3.png)

---
# Operacionalizando en el server

--
- Cada elemento de entrada reactivo que pongamos en la UI puede y debe, ser operacionalizado en el server para conducir cambios en el mapa.

--
- En el caso de las aplicaciones simples vistas anteriormente esas operaciones pueden ser directas o llevadas a cabo con un conductor reactivo (reactive u observer)

--
- Para conducir los cambios en nuestro mapa base emplearemos principalmente los *observers* y la función *leafletProxy()* para que nuestro mapa se actualice sin tener que recargarse cada vez que haya un cambio en la UI

--
- A continuación lo primero será establecer el cambio reactivo de leyenda creando un *observeEvent({})*, que pondremos en el server después de nuestro mapa base.

--

```r
#mapa temático en proxy
  observeEvent(input$campo, {
    
  })
```

--
- Debemos indicar cuál es la entrada reactiva a observar y escribir el código a ejecutar dentro de las {}

---

--




```r
#mapa temático en proxy
  observeEvent(input$campo, {
    tabla &lt;- valpo %&gt;% as.data.frame() # convirtiendo sf a data frame simple
    valores &lt;- tabla[,input$campo] %&gt;% as.numeric() #extrayendo valores de columna
    pal &lt;- colorQuantile(palette = "viridis",domain = valores,n = 10)#paleta
    pal_colors &lt;-  sort(valores) %&gt;% pal() %&gt;% unique() #Colores para leyenda
    pal_labels &lt;- quantile(valores, seq(0, 1, 0.1)) # creación de quantiles para etiquetas
    pal_labels &lt;- paste(lag(pal_labels), pal_labels, sep = " - ")[-1] # removemos el primer lag por ser NA
    
    # mapa reactivo
    proxyMap &lt;- leafletProxy('map') %&gt;% clearControls() %&gt;% clearShapes() 
  })
```

--
- Esta sección de código nos permite  crear la paleta de colores de acuerdo a la selección en la UI

--
- Luego se crea el objeto *proxyMap* limpiando los controles y los shapes, para que al cambiar dinámicamente no haya una superposición de capas.

--
- Para asegurar la disposición correcta de la información crearemos 1 versión de nuestro mapa para cada variable, 4 en este caso, y emplearemos la función condicional *if()* para el control del renderizado

---

--
- Ejemplo para un condicional

--

```r
if(input$campo == "T_POB"){
     proxyMap %&gt;% addPolygons(data = valpo,group = 'CENSO INE, 2017', fillColor = ~pal(T_POB), 
                               fillOpacity = 0.8,stroke = T,weight = 0.25, smoothFactor = 0.2) %&gt;%
        addLegend("bottomleft", colors = pal_colors, labels = pal_labels, 
                  title = "Total de personas por comuna",opacity = 0.8,group = 'Leyenda') %&gt;% 
        addLayersControl(overlayGroups = c('CENSO INE, 2017'),position ="bottomleft")
    }
```

--
- Este código debemos replicarlo cambiando el nombre de la columna, el título de la leyenda y el campo de relleno en el argumento *fillColor*

---
class: middle, center
![:scale 70%](app1.4.png)
---
# Etiquetas

--
- Además incorporar la leyenda, podemos hacer mucho más amigable la navegación por el mapa incorporando etiquetas a nuestra información.

--
- Para esto disponemos de dos argumentos que son *popup* y *label*

--
- Ambos argumentos se pueden emplear en las funciones de addPolygons, addMarkers, etc.

--
- Ejemplo para popup

--

```r
 if(input$campo == "T_POB"){
     proxyMap %&gt;% addPolygons(data = valpo,group = 'CENSO INE, 2017', fillColor = ~pal(T_POB), 
                               fillOpacity = 0.8,stroke = T,weight = 0.25, smoothFactor = 0.2,
                              popup = ~T_POB %&gt;% as.character()) %&gt;%
        addLegend("bottomleft", colors = pal_colors, labels = pal_labels, 
                  title = "Total de personas por comuna",opacity = 0.8,group = 'Leyenda') %&gt;% 
        addLayersControl(overlayGroups = c('CENSO INE, 2017'),position ="bottomleft")
    }
```

--
- *Importante*: Aquí empleamos la función *as.character()* para indicar que debe mostrar texto, ya que a veces al mostrar números popup presenta problemas.

---
class: middle, center
![:scale 70%](app1.5.png)
---
- Ejemplo para label

--

```r
 if(input$campo == "T_POB"){
     proxyMap %&gt;% addPolygons(data = valpo,group = 'CENSO INE, 2017', fillColor = ~pal(T_POB), 
                               fillOpacity = 0.8,stroke = T,weight = 0.25, smoothFactor = 0.2,
                              label = ~T_POB) %&gt;%
        addLegend("bottomleft", colors = pal_colors, labels = pal_labels, 
                  title = "Total de personas por comuna",opacity = 0.8,group = 'Leyenda') %&gt;% 
        addLayersControl(overlayGroups = c('CENSO INE, 2017'),position ="bottomleft")
    }
```

--
- Label mostrará lo mismo que popup pero sin necesidad de pinchar el polígono.

--
- *label* suele ser más simple y fácil de manipular empleando HTML a través de la función *labelOptions()*

--

```r
 if(input$campo == "T_POB"){
     proxyMap %&gt;% addPolygons(data = valpo,group = 'CENSO INE, 2017', fillColor = ~pal(T_POB), 
                               fillOpacity = 0.8,stroke = T,weight = 0.25, smoothFactor = 0.2,
                              label = ~T_POB,labelOptions = labelOptions(style = list("color" = "black", 
                                                             "font-size" = "16px",
                                                             "font-family" = "serif",
                                                             "font-weight" = "bold")) %&gt;%
        addLegend("bottomleft", colors = pal_colors, labels = pal_labels, 
                  title = "Total de personas por comuna",opacity = 0.8,group = 'Leyenda') %&gt;% 
        addLayersControl(overlayGroups = c('CENSO INE, 2017'),position ="bottomleft")
    }
```

---
class: middle, center
![:scale 60%](app1.6.png)

---
# Opciones de realce de polígonos

--
- Podemos controlar la vista de un polígono al posicionarnos sobre él empleando el argumento *highlight* y la función *highlightOptions()*

--
- Ejemplo para un solo condicional

--

```r
if(input$campo == "T_POB"){
     proxyMap %&gt;% addPolygons(data = valpo,group = 'CENSO INE, 2017', fillColor = ~pal(T_POB), 
                               fillOpacity = 0.8,stroke = T,weight = 0.25, smoothFactor = 0.2,
                              label = ~T_POB,labelOptions = labelOptions(style = list("color" = "black", 
                                                                                      "font-size" = "16px",
                                                                                      "font-family" = "serif",
                                                                                      "font-weight" = "bold")),
                              highlight = highlightOptions(weight = 5,color = "white",
                                fillOpacity = 1,bringToFront = TRUE)) %&gt;%
        addLegend("bottomleft", colors = pal_colors, labels = pal_labels, 
                  title = "Total de personas por comuna",opacity = 0.8,group = 'Leyenda') %&gt;% 
        addLayersControl(overlayGroups = c('CENSO INE, 2017'),position ="bottomleft")
    }
```

--
- *Importante*: recuerde que estos argumentos nuevos deben estar en los 4 bloques condicionales para que se vean los efectos en las capas al cambiar de variable a mapear.


---
class: middle, center
![:scale 70%](app1.7.png)

---
background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "zenburn",
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
