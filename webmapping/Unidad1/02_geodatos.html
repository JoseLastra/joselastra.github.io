<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Manipulación básica de geo-datos en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mg. José A. Lastra  Matías Olea" />
    <link href="libs/remark-css/fc.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Manipulación básica de geo-datos en R
## Curso: Introducción al análisis espacial y web-mapping <br>con Google Earth Engine y R Shiny<br>
### Mg. José A. Lastra <br>Matías Olea<br>
### Laboratorio Geo-Información y Percepción Remota
### 30/11/2020

---

background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%




---

Librerías utilizadas en esta sesión


```r
library(tidyverse)
library(rgdal)
library(raster)
library(sf)
library(rasterVis)
```

--
- El trabajo con geo-datos en R es un mundo creciente y bastante dinámico en torno a las funcionalidades y análisis que se pueden realizar.

--
- Para efectos de un funcionamiento óptimo de nuestras aplicaciones en *shiny*, veremos como interoperar entre los objetos de *rgdal* y *sf*. Ambas, diseñadas para manipular información espacial de tipo vectorial (shapefiles, geopackages, etc.)

--
- Usaremos de preferencia *sf* para el análisis de nuestros datos por que nos permitirá emplear las bondades de las funciones de manipulación de data frames de *tidyverse* que iremos viendo a lo largo del curso.

--
- *raster* lo usaremos para manipulación de imágenes o datos en formato raster (modelos de elevación, temperaturas, datos satelitales, etc.) y será un eje central de la manipulación y análisis de esas matrices numéricas.

---
# Lectura de datos vectoriales

--
- Podemos leer diferentes clases de archivos (shp, geopackage, geojson,tif, etc.) empleando diversas funciones de lectura disponibles en las librerías mencionadas anteriormente

--
- Es importante considerar que cada una tendrá una estructura específica al momento de ser leída como objeto en R.

--
- Debemos recordar lo básico dentro de una estructura espacial (geometría, resolución, sistema de referencia, etc.)

--
- Estos apesctos serán relevantes de acuerdo a la naturaleza de la información que estemos trabajando.

--
- En el caso de la información vectorial lo importante será su geometría (puntos, líneas o polígonos) y su sistema de referencia espacial o sistema de coordenadas.

---

Leyendo datos *"complejos"* usando librería *rgdal*
--

```r
#read spatial data
vinaDelMar &lt;- readOGR('viña_del_mar.shp')
```


```
## OGR data source with driver: ESRI Shapefile 
## Source: "C:\Users\josel\Documents\github\joselastra.github.io\webmapping\Unidad1\viña_del_mar.shp", layer: "viña_del_mar"
## with 3570 features
## It has 16 fields
```

```
##    user  system elapsed 
##    1.78    0.51    2.35
```

--
- Demora mucho para capas grandes o con mucho detalle 
- Poco óptimo para trabajo con aplicaciones y grandes volúmenes de datos
- Ventaja: paquete más antiguo y con mayores compatibilidades e interoperabilidad
- Desventaja: estructura algo compleja y demora en la carga de ciertos archivos


---
¿Alternativas? Usemos la librería *sf*

--

```r
#read spatial data
vinaDelMar &lt;- read_sf('viña_del_mar.shp')
class(vinaDelMar)
```

```
## [1] "sf"         "tbl_df"     "tbl"        "data.frame"
```


```
##    user  system elapsed 
##    0.06    0.05    0.11
```

--
- Simplifica la estructura de nuestra información espacial
- Lectura considerablemente más rápida de las capas
- permite manipular la información de una manera más flexible
- Desventajas: librería nueva aún no tiene completa compatibilidad con todas las funciones; [Pueden revisar](https://github.com/r-spatial/sf/wiki/migrating)

---
#Visualicemos los datos

--
- La visualización más elemental de un objeto leído con *sf* puede realizarse mediante la función *plot()*
--

- se debe considerar seleccionar un campo de interés para visualizar, de no hacerlo se visualizan todos por defecto.
--

Visualizando número de personas por manzana censal


```r
#Basic plot
plot(vinaDelMar['PERSONA'])
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-6-1.png" width="324" style="display: block; margin: auto;" /&gt;

---
#Mejorando algo el gráfico

--
- Al igual que para el gráfico de información alfanumérica, podemos incorporar argumentos que mejoren la visualización.

--
- Podemos emplear *?plot.sf* en la consolta para ver más opciones
--

```r
plot(vinaDelMar['PERSONA'],breaks='quantile',key.pos = 4, axes=T)
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-7-1.png" width="504" style="display: block; margin: auto;" /&gt;
---
#Si solo quiero la geometría

--
- Además de poder ver información, podemos simplemente revisar la geometría de los datos empleando *st_geometry()*

```r
#we can use tidyverse code!
vinaDelMar %&gt;% st_geometry() %&gt;% plot() #area
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-8-1.png" width="504" style="display: block; margin: auto;" /&gt;

---

--
- También se pueden obtener otros productos como por ejemplo los centroides

--
- Y podemos anidar funciones usando el *%&gt;%*  

```r
#we can use tidyverse code!
vinaDelMar %&gt;% st_geometry() %&gt;% st_centroid() %&gt;% plot()
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-9-1.png" width="504" style="display: block; margin: auto;" /&gt;

---
#Cambiando proyección

--
- Una práctica común al manejar información geográfica es disponer de datos con diferentes sistemas de referencia

--
- Nosotros normalmente trabajamos en UTM (WGS-84), pero podemos requerir el uso de otro sistema de referencia en ciertos momentos, por ejemplo al poner un mapa en *leaflet* (lo veremos más adelante!)

--
- Un buen lugar si uno no se sabe los EPSG es buscar [aquí](https://epsg.io/) y podremos transformar usando *st_transform()*

```r
vinaUTM &lt;- vinaDelMar %&gt;% st_transform(crs = 32719) 
#esto es lo mismo
vinaUTM &lt;- vinaDelMar %&gt;% st_transform(crs = '+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs ') 
```


```
## $input
## [1] "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs "
```

---
# Algunas cosas básicas

--
- Buffer o área de influencia

```r
#buffers
vinaUTM %&gt;% st_geometry() %&gt;% st_buffer(dist = 100) %&gt;% plot()
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-12-1.png" width="504" style="display: block; margin: auto;" /&gt;

---

--
- Filtro por atributos [podemos usar filtros convencionales de data frames!]

```r
#attribute selection
  gomezCarreno &lt;- vinaUTM %&gt;% filter(DISTRIT == 'GÓMEZ CARREÑO')
  plot(gomezCarreno['PERSONA'], breaks='jenks')
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-13-1.png" width="504" style="display: block; margin: auto;" /&gt;

---
#Creando una columna nueva

--
- La creación de nueva data dentro de las tablas de atributos es bastante simple utilizando la función *mutate()*

--
- En este ejemplo crearemos una columna con el área en hectáreas de la zona de Gómez Carreño y luego calcularemos la densidad de población por manzana censal

--

```r
#area square meters
gomezCarrenoDensity &lt;- gomezCarreno %&gt;% mutate(area_ha = st_area(gomezCarreno)/10000)

#density by block
area_manzana &lt;- gomezCarrenoDensity$area_ha %&gt;% as.numeric()
poblacion &lt;- gomezCarrenoDensity$PERSONA %&gt;% as.numeric()
gomezCarrenoDensity &lt;- gomezCarrenoDensity %&gt;% mutate(densidad = (poblacion/area_manzana))
```

--
- Podemos escribir nuestro nuevo shape en disco empleando *st_write()*

```r
st_write(gomezCarrenoDensity,'densidad_GC.shp')
```

---
# sf y ggplot2

--
- Gracias a la estructura con que son leídos nuestros archivos vectoriales con sf, podemos fácilmente graficar empleando ggplot como soporte gráfico empleando *geomo_sf()*


```r
ggplot() + geom_sf(data = gomezCarrenoDensity, aes(fill=densidad)) + 
  scale_fill_viridis_c() + theme_bw()
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-16-1.png" width="504" style="display: block; margin: auto;" /&gt;

---
# Archivos raster

--
- En general vamos a tener diferentes fuentes de información:
 * Interpolaciones
 * Imágenes satelitales
 * Modelos (oceánicos, climáticos, hidrodinámicos, etc.)
 
--
- Aquí además de tener en cuenta el sistema de referencia espacial debemos considerar un aspecto clave que tiene que ver con la resolución espacial de la información, también entendida como el tamaño del pixel o celda.

--
- Para estos ejemplos utilizaremos información gruesa de [WorldClim](https://www.worldclim.org) 

- Para obtener la información haremos uso de la función *getData()* del paquete *raster*

--
- Esto es información abierta, por lo que está disponible para su uso sin mayores restricciones.

--
- En este ejemplo descargaremos la información  y la guardaremos en disco en formato *GeoTiff* y en formato de datos enteros con signo ya que tenemos valores positivos y negativos.

--
- Para saber más sobre los formatos y los tipos de dato use *?writeRaster*


```r
#present climatologies
temperatura &lt;- getData('worldclim', var='tmean', res=10) 
#writing raster data
writeRaster(temperatura,filename = 'temperatura_WC.tif',format='GTiff',datatype='INT2S')
```

--
- *Importante*: recuerde siempre ver en que directorio se encuentra trabajando, para saber donde está guardando o direccione hacia donde quiera guardar.

---
#Leyendo nuestros datos raster

--
- Los archivos raster más comunes pueden venir en formatos de una banda (raster) o multibanda (raster stack), es decir, una capa de información o varias capas en el mismo archivo.

--
- Como la información de temperatura que descargamos es un *RasterStack* haremos uso de *stack()* de la librería *raster*. Para leer bandas individuales podemos emplear la función *raster()*


```r
temperatura &lt;- stack('temperatura_WC.tif')
#Ploting first month
plot(temperatura[[1]]) 
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-18-1.png" width="720" style="display: block; margin: auto;" /&gt;

--
- El *[[]]* nos permite seleccionar la banda de información que queremos desplegar, en este caso el mes.
---
#Cortando y enmascarando rasters

--
- Otro aspecto relevante es ajustar la información espacial a nuestra área de interés para disminuir el volumen de la información y hacerla más manejable

--
- La función *crop()* permite cortar considerando una extensión rectangular y la función *mask()* permite trabajar con los límites reales de mi polígono (ejemplos: una cuenca, una comuna, distrito, etc.)


```r
#reading shape for crop and mask
chile &lt;- read_sf('cl_continental_geo.shp')

tempCHL &lt;- temperatura %&gt;% crop(chile) %&gt;% mask(chile)
plot(tempCHL[[1]])
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-19-1.png" width="720" style="display: block; margin: auto;" /&gt;

---
#Algunos cálculos sobre rasters

--
- En el caso de la información raster los valores se almacenan en las celdas y no en una tabla por lo que hay que tener claridad de las características de la información

--
- En este ejemplo reescalaremos los datos a sus valores normales y asignaremos nombres a las bandas.

```r
#rescale values
tempCHL &lt;- tempCHL/10 
names(tempCHL) &lt;- month.abb #change layers's names
rasterVis::levelplot(tempCHL) #plot 
```

&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-20-1.png" width="1008" style="display: block; margin: auto;" /&gt;

---
- Podemos también calcular estadísticas para cada pixel y crear un objeto monobanda y combinarlos en un stack como se ve en el ejemplo.


```r
t_mean &lt;- tempCHL %&gt;% mean(na.rm = T) #media
t_min &lt;- tempCHL %&gt;% min(na.rm = T) #min
t_max &lt;- tempCHL %&gt;% max(na.rm = T) #max
CHL_layers &lt;- stack(t_min,t_mean,t_max) #bind data
names(CHL_layers) &lt;- c('min','mean','max')
rasterVis::levelplot(CHL_layers)
```

---
&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-22-1.png" width="504" style="display: block; margin: auto;" /&gt;
---
#Rasters y ggplot

--
- A pesar de la naturaleza de la información, podemos utilizar ggplot para graficar información proveniente de archivos rasters

--
- Recordemos que un raster es básicamente una matriz de información formada por filas y columnas, que además disponen de información espacial.

--
- Para poder emplear ggplot y raster en conjunto, debemos convertir la información como se muestra en el ejemplo, empleando la función *as()* que permite transformar entre diferentes clases de objetos

--

```r
#selecting mean temperature
chl_mean &lt;- CHL_layers[[2]]
```

--

```r
#converting raster to data frame with coordinates
chl_meanDF &lt;- chl_mean %&gt;% as("SpatialPixelsDataFrame") %&gt;% 
  as.data.frame() %&gt;% rename( t_mean = mean)
```

--

```r
ggplot() + geom_tile(data = chl_meanDF, aes(x = x, y = y,fill = t_mean)) + 
  geom_sf(data = chile, alpha = 0,color='black') + theme_bw() + 
  scale_fill_viridis_c() + xlab("") + ylab("")
```

---
&lt;img src="02_geodatos_files/figure-html/unnamed-chunk-26-1.png" width="504" style="display: block; margin: auto;" /&gt;

---
background-image: url(logo_labgrs_color.png)
background-position: center
background-size:40%
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "zenburn",
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
